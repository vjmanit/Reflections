What happens when you initialize a repository? Why do you need to do it?
     We can initialize a git repositiry using command "git init".Whwn we initialize a git repository then a file named ".git" is created that contain information about the repository.


How is the staging area different from the working directory and the repository?
What value do you think it offers?
     Staging area is the area just before commiting a file.Initially file is created in working directory and repository is empty then before commiting a logical change we have to add it to staging area by using command "git add" and after adding a file in staging area then we perform commit and repositiry will not be empty after the commit operation.

How can you use the staging area to make sure you have one commit per logical
change?
    If i  have changed the file in working directory and haven't added this in staging area then i can see the difference b/w files in working directory and staging area using commad "git diff".If i have already added it in staging area then git diff will show no difference.Now we can see the difference b/w staging area and previously commited file using command "git diff --staged".If there is no logical change in staging area then git diff --staged will show no difference b/w them.

What are some situations when branches would be helpful in keeping your history
organized? How would branches help?
 	There are following situations when branches would be helpful.
	->When we are switching to some different versions
	->When we want to work on any specific features
	Bsically branches in git gives us freedom to think in any specific region of our project.The master branch always saves the original version and whenever we want to work on any specific direction we create a new branch and think freely in that direction because we have no fear for losing the data as the original data is saved in some other branch.	

How do the diagrams help you visualize the branch structure?
	Diagrams help us to visualize the branch structure by checking reachability of each branch and helps us to find which branch contains which commit.It also helps us to find the detached head state i.e the new commit on a head commit.

What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?
	 Result of merging two branch gives a new updated branch including the features of both the branches.We represent it in diagram to check the reachabiity as well as how many commits is used in the new branch

What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges
manually?